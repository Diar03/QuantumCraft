# ------------------------------------------------------------------------
# This code has been generated by an AI assistant.
# Please review and verify its correctness before use.
# ------------------------------------------------------------------------

import subprocess
import psutil
import time
import pandas as pd
from threading import Thread, Lock
import argparse

# --- Global Variables ---
data = []  # Shared data list for threads
data_lock = Lock()  # Thread synchronization lock

# --- Functions ---

def launch_game_instance(instance_number):
    """Launches a single instance of the game in the background."""
    subprocess.Popen(["./QuantumCraft.x86_64"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    print(f"Launched instance {instance_number}")

def monitor_process(process, interval):
    """Monitors resource and network usage of a single game process."""
    while process.is_running():
        try:
            with process.oneshot():
                process_info = process.as_dict(attrs=['pid', 'cpu_percent', 'memory_info', 'connections', 'create_time'])
                net_sent = sum(conn.bytes_sent for conn in process_info['connections'])
                net_recv = sum(conn.bytes_recv for conn in process_info['connections'])

                with data_lock:  # Acquire lock before modifying shared data
                    data.append({
                        'Timestamp': pd.Timestamp.now(),
                        'Instance': process_info['pid'],
                        'CPU (%)': process_info['cpu_percent'],
                        'Memory (MB)': process_info['memory_info'].rss / 1024 / 1024,
                        'Net Sent (KB)': net_sent / 1024,
                        'Net Recv (KB)': net_recv / 1024
                    })
        except psutil.NoSuchProcess:
            print(f"Process {process.pid} has ended")
            break  # Exit the loop for this process

        time.sleep(interval)  # Use the provided interval

# --- Main Script ---
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Launch and monitor Unity game instances.")
    parser.add_argument("num_instances", type=int, help="Number of game instances to launch")
    parser.add_argument("interval", type=float, help="Data collection interval in seconds")
    args = parser.parse_args()

    game_processes = []
    for i in range(args.num_instances):
        launch_game_instance(i + 1)
        time.sleep(2) # Delay between launching instances to avoid overloading the system and joining different rooms

    # Find game processes and start monitoring threads
    threads = []
    for proc in psutil.process_iter(['pid', 'name']):
        if proc.info['name'] == "./QuantumCraft.x86_64":  # Match executable name directly
            game_processes.append(proc)
            thread = Thread(target=monitor_process, args=(proc, args.interval))
            threads.append(thread)
            thread.start()

    # Wait for all threads to finish
    for thread in threads:
        thread.join()

    df = pd.DataFrame(data)
    df.to_csv("game_resource_data.csv", index=False)

    # ... (Your plotting or analysis code here)
